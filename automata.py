# Author: Antonio Lang
# Date: 26 February 2023

import random

class AutomatonNode:
    def __init__(self, state, next=[("", None)]) -> None:
        self.state = state
        self.next = next
    def __str__(self) -> str:
        return f"State {self.state}, next node list: {self.next}"

def create_automata(option) -> AutomatonNode: 
    # automata to recognize the following languages
    if option == 1: # baa+
        q3 = AutomatonNode("accept")
        q2 = AutomatonNode("valid", [("a", q3)])
        q3.next.append(("a", q2))
        q1 = AutomatonNode("valid", [("a", q2)])
        q0 = AutomatonNode("valid", [("b", q1)])
        return q0
    if option == 2: # (abba)+ or (baab)+
        q4 = AutomatonNode("accept")
        q3 = AutomatonNode("valid", [("a", q4)])
        q2 = AutomatonNode("valid", [("b", q3)])
        q1 = AutomatonNode("valid", [("b", q2)])
        q4.next = [("", None), ("a", q1)]
        q8 = AutomatonNode("accept")
        q7 = AutomatonNode("valid", [("b", q8)])
        q6 = AutomatonNode("valid", [("a", q7)])
        q5 = AutomatonNode("valid", [("a", q6)])
        q8.next.append(("b", q5))
        q0 = AutomatonNode("valid", [("a", q1),("b", q5)])
        return q0
    if option == 3: # zero through ninety nine
        q1 = AutomatonNode("accept") # terminal accept state
        ones_list = ['one','two','three','four','five','six','seven','eight','nine']
        spaced_ones_list = [' one',' two',' three',' four',' five',' six',' seven',' eight',' nine']
        terminal_list = [q1] * len(spaced_ones_list)
        q2 = AutomatonNode("accept", list(zip(spaced_ones_list, terminal_list))) # accept state for twenty-ninety
        q2.next.append(("", None))
        special_nums = ones_list.copy()
        special_nums.insert(0, "zero")
        special_nums += ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen',
                         'sixteen','seventeen','eighteen','nineteen']
        q1_nodes = [q1] * len(special_nums)
        q1_paths = list(zip(special_nums, q1_nodes))
        bases = ["twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
        q2_nodes = [q2] * len(bases)
        q2_paths = list(zip(bases, q2_nodes))
        q0 = AutomatonNode("valid", q1_paths+q2_paths)
        return q0

def generate_language(automata) -> str:
    # returns an utterance generated by the automaton
    utterance = []
    node = automata
    generate_utterance = True
    while generate_utterance:
        branch = random.randint(0, len(node.next)-1)
        if node.next[branch][1] == None:
            break
        utterance.append(node.next[branch][0])
        node = node.next[branch][1]
    return ''.join(utterance)

def recognize_language(automata, utterance) -> int:
    # wrapper function to call the recursive function and cast the output to int
    return int(determine_valid_word(automata, utterance, 0))

def determine_valid_word(automaton_node, utterance, chars_read) -> bool:
    # recursive function to check if a word exists in a given automaton's language

    # consider deliminting on space for zero - ninety nine automata
    if automaton_node is None: return False
    if automaton_node.state == "accept" and chars_read == len(utterance):
        return True
    elif len(utterance) == chars_read and automaton_node.state != "accept":
        return False
    else:
        valid_chars = [char[0] for char in automaton_node.next]
        if utterance[chars_read] in valid_chars:
            branch = valid_chars.index(utterance[chars_read])
            return determine_valid_word(automaton_node.next[branch][1],
                                        utterance, chars_read+1)
        else:
            return False

if __name__ == '__main__':
    automaton = create_automata(3)
    print(generate_language(automaton))
    # print(recognize_language(automaton, "ten"))